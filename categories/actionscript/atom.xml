<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ActionScript | Till Schneidereit]]></title>
  <link href="http://tschneidereit.github.io/categories/actionscript/atom.xml" rel="self"/>
  <link href="http://tschneidereit.github.io/"/>
  <updated>2013-07-02T02:59:21+02:00</updated>
  <id>http://tschneidereit.github.io/</id>
  <author>
    <name><![CDATA[Till Schneidereit]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mario Mushroom: Now with 80% less awesome]]></title>
    <link href="http://tschneidereit.github.io/2011/10/22/mario-mushroom-now-with-80-less-awesome/"/>
    <updated>2011-10-22T14:34:04+02:00</updated>
    <id>http://tschneidereit.github.io/2011/10/22/mario-mushroom-now-with-80-less-awesome</id>
    <content type="html"><![CDATA[<p><strong>tl;dr:</strong>
Don&rsquo;t use the Mario Mushroom Operator if you don&rsquo;t want your setter to be
invoked more than once.</p>

<p><strong>Update:</strong> I totally forgot to mention that I found out about this problem with <a href="https://twitter.com/darscan">@darscan</a> while working on <a href="http://github.com/tschneidereit/SwiftSuspenders/">Swiftsuspenders</a> and <a href="http://github.com/robotlegs/robotlegs-framework/">Robotlegs</a> code.</p>

<p><strong>The Details</strong>
I think it was <a href="twitter.com/#!/robpenner/">@robpenner</a> who coined the term
&ldquo;Mario Mushroom Operator&rdquo;.</p>

<p>In case you&rsquo;re wondering, the Mario Mushroom Operator is this: <code>||=</code>.</p>

<p>A good translation for how the MMO™ works seems to be this:
<code>as3
if (!field) { field = value; }
</code></p>

<p>In case you&rsquo;re still wondering, here&rsquo;s how you&rsquo;d use it:
<code>as3
function useRuntimeDefault(input:Object):void { input
||= getDefaultValue(); }
</code></p>

<p>I.e., the most important use-case for the MMO™ is to apply runtime-determined
default values for method arguments.</p>

<p>Now, that&rsquo;s really useful and you might be wondering what could possibly go
wrong with that.</p>

<p>Consider this snipped of code:
```as3
private var <em>setOnce : Boolean; private var </em>value :
Object;</p>

<p>public function set value(value : Object) : void { if (<em>setOnce) { throw new
Error(&lsquo;Value can only be set once&rsquo;); } </em>setOnce = true; <em>value = value; }
public function get value() : Object { return </em>value; }
```</p>

<p>Used in a class, this code encapsulates a value that can be set exactly once,
after which it can only be read.</p>

<p>With me still? Splendid.</p>

<p>In fact, you&rsquo;re probably already guessing what comes now: Using the MMO™ to
assign this once-settable value iff it hasn&rsquo;t already been set:
<code>as3
value ||= {};
</code></p>

<p>And here, finally, things go awry. As it turns out, the MMO™&rsquo;s translation
given earlier isn&rsquo;t quite correct. Instead, the compiler (or the VM, I haven&rsquo;t
checked the bytecode) seems to translate our usage of the MMO™ to something
along the following lines:
<code>as3
field = field ? field : {};
</code></p>

<p>In summary, instead of guarding the assignment to a field as an if statement
would do, the MMO™ only chooses between two values to use in the assignment
like the ternary operator does.</p>

<p>In case you&rsquo;re now thinking that that doesn&rsquo;t affect you because you, just as
every sane person you know, don&rsquo;t ever have use-cases for one-time assignable
fields, ask yourself whether you can be certain that all your setters are
side-effect free if you re-assign the same value and that you never, ever,
care about the overhead associated with double-setting values needlessly.
&ldquo;Yes&rdquo; and &ldquo;yes&rdquo;? Cool. &ldquo;Mmh&rdquo; and &ldquo;not sure&rdquo;: Weep with me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftSuspenders 1.6: A Tale of Small Changes and Big Plans]]></title>
    <link href="http://tschneidereit.github.io/2011/02/05/swiftsuspenders-1-6-a-tale-of-small-changes-and-big-plans/"/>
    <updated>2011-02-05T16:15:28+01:00</updated>
    <id>http://tschneidereit.github.io/2011/02/05/swiftsuspenders-1-6-a-tale-of-small-changes-and-big-plans</id>
    <content type="html"><![CDATA[<p>I just released version 1.6 of my not-so-small-anymore IoC container
<a href="https://github.com/tschneidereit/SwiftSuspenders">SwiftSuspenders</a>. This
release marks the end of the line for 1.x-releases, all future development
work will go towards the all-new, shiny 2.0 release. Bug fixing will continue
as per usual, of course.</p>

<h3>Small Changes?</h3>

<p>Yes &ndash; in 1.6:</p>

<ul>
<li><p>An easy but nevertheless significant performance optimizations for child injectors: Through a slight refactoring of the InjectionPoint class, I was able to make it fully independent from the injector that creates them, enabling them to be shared among all injectors in the VM instance. This allows them to be cached once, removing the significant performance overhead associated in inspecting classes to find injection points for all but the first injector.</p></li>
<li><p>Some usability improvements such as better error, warning and info messages on trying to instantiate interfaces, re-mapping previously mapped types and construction of dummy instances to work around Flash Player bugs.</p></li>
</ul>


<h3>Right, but Big Plans?</h3>

<p>Indeed &ndash; for 2.0!</p>

<p>For the next major release, I plan to change things up quite a bit. The main
features on the roadmap are:</p>

<ul>
<li>a much nicer API</li>
<li>factory mappings</li>
<li>field mappings</li>
<li>live injections</li>
<li>optional injections</li>
<li>weak mappings in child injectors</li>
<li>full live-cycle management with [PreDestroy] annotations</li>
<li>a new format for external, runtime-loadable definition of both injection points and type mappings</li>
<li>full implementation of the <a href="https://github.com/darscan/AS3-DI-Metadata">metadata standardization</a> <a href="http://twitter.com/darscan">@darscan</a> started, for example:</li>
<li>optionally shortening <code>[Inject(name='name')]</code> to <code>[Inject('name')]</code></li>
</ul>


<h3>That sounds just swell, but I&rsquo;d really like some details, please!</h3>

<p>Of course you do!</p>

<h4>The shiny new API</h4>

<p>SwiftSuspenders' API mainly consists of methods that facilitate the mapping of
types (and, optionally, names) to responses. Internally, this already is a
two-step process: First, an object is created that contains the request
configuration (i.e., the type and the optional name) and second, this request
is assigned a response of a certain type: A value, class, singleton or rule
mapping.</p>

<p>While 2.0 will ship with a façade to make porting from 1.x easy, the real
interface will expose this process as the two steps it really is. Look forward
to seeing mapping commands that look (approximately) like this:</p>

<p><code>as3    
injector.map(YourClass); //current equivalent: injector.mapClass(YourClass, YourClass);
injector.map(YourClass, 'name'); //current equivalent: injector.mapClass(YourClass, YourClass, 'name');
injector.map(YourClass).to(YourClass); //equivalent to the first mapping (i.e.: optional)
injector.map(YourClass, 'name').to(YourClass); //equivalent to the second mapping (i.e.: optional)
injector.map(YourInterface).toType(YourClass); //current equivalent: injector.mapClass(YourInterface, YourClass);
injector.map(YourClass).asSingleton(); //current equivalent: injector.mapSingleton(YourClass);
injector.map(YourInterface).toType(YourClass).asSingleton(); //current equivalent: injector.mapSingletonOf(YourInterface, YourClass);
injector.map(YourInterface).toValue(value); //current equivalent: injector.mapValue(YourInterface, value);
injector.map(YourInterface).toRule(otherRule); //current equivalent: injector.mapRule(YourInterface, otherRule);
var request : InjectionRequest = injector.map(YourClass); //current equivalent: var request : InjectionConfig = injector.getMapping(YourClass);
</code></p>

<p>Basically, the API will be somewhat more DSL-ish, without going all the way
into that direction, though: I like to think of it as bundling up all
parameters related to one concept in one method call: First everything related
to <em>what</em> gets mapped, then, optionally, <em>to what</em> it gets mapped and finally,
<em>how</em> its being mapped.</p>

<p>Additionally, the small rest of the API will be subject to some tweaks, I
suppose.</p>

<h4>Factory mappings</h4>

<p>I haven&rsquo;t really gotten through the concept phase for these. The absolute
minimum is support for <code>injector.map().toFactory()</code> and
<code>injector.map().toFactoryMethod()</code>, but if I come up with some clever
mechanism for parameterizing specific injections, I would like to support that
as well.</p>

<h4>Field mappings</h4>

<p>In order to turn SwiftSuspenders into a light-weight one-way binding solution,
2.0 will support mapping of fields in objects with
<code>injector.map().toField(fieldName, inObject)</code>. If the mapped field is
bindable, SwiftSuspenders will listen to its change events and update the
affected live injections:</p>

<h4>Live injections</h4>

<p>Now those are something I&rsquo;m really looking forward to. By specifying the
<code>live</code>-parameter in your <code>Inject</code>-metadata (as in <code>[Inject(live)]</code>), you
basically create a one-way binding that updates the value as soon as the
associated mapping changes or, in the case of field mappings, the relevant
binding event is dispatched as described above.</p>

<h4>Optional injections</h4>

<p>These are exactly what you think they are. <code>[Inject(optional)]</code> will instruct
the injector not to throw an exception if it can&rsquo;t find a mapping for the
requested type.</p>

<h4>Weak mappings</h4>

<p>Imagine you have a module that you want to test &ndash; or perhaps even deploy &ndash;
standalone but <em>also</em> want to load into a bigger application. Now this module
might have some configuration that&rsquo;s different based on what context it gets
loaded into. If its loaded into another application, all or parts of the
configuration should be supplied by that application, but if its running
standalone, it has to deal with configuration all by itself. Enter weak
mappings: These instruct the injector to always ask its parent injector if it
has a mapping for the injection request. Only if that returns empty, the
weakly mapped value, in this case the module&rsquo;s configuration, is used.</p>

<h4>Tear-down with [PreDestroy]</h4>

<p>Just as <code>[Inject]</code> is used to build object graphs, <code>[PreDestroy]</code> facilitates
tearing them down. When instructed to destroy a certain instance that it
created itself or that was injected into with <code>injector.injectInto</code>,
SwiftSuspenders will first go through all injection points in the instance and
destroy those recursively (if they are only used by this instance, not if they
are singleton or value mappings, of course) and the invoke all methods marked
with <code>[PreDestroy]</code> metadata.</p>

<p>This will probably be used to replace the currently hard-coded <code>preRemove</code> and
<code>onRemove</code> methods in Robotlegs mediators.</p>

<h4>New runtime-loadable configuration format for injection points and mappings</h4>

<p>The current XML-based configuration format was solely meant to work around
restrictions in the Flash CS* AS3 compiler which doesn&rsquo;t support custom
metadata out of the box. This problem has since been <a href="http://www.patrickmowrer.com/2010/03/03/compiling-custom-as3-metadata-flash-professional">worked around</a>, rendering the format obsolete as it is right now. As
quite some people expressed interest in being able to mix hard-coded and
runtime-loaded configuration, I will try to come up with a good format for
that. For now, I don&rsquo;t have anything in that direction, so we&rsquo;ll see how that
goes. And if <em>you</em> want to define just such a format: Please do (and tell me
about it).</p>

<h4>Standardization FTW</h4>

<p>One thing I like about Robotlegs is how @darscan went to great lengths to
prevent as much lock-in as possible: Not only is the <a href="https://github.com/robotlegs/robotlegs-framework/blob/master/src/org/robotlegs/core/">framework&rsquo;s core</a>
just a set of interfaces that
makes it easy to roll your own for each part, the framework specifically tries
to make as many parts of your application independent and even ignorant of its
existence as possible. Toward that end, Shaun started a <a href="https://github.com/darscan/AS3-DI-Metadata">metadata standardization effort</a> with the
goal of getting as much agreement on the format of injection point-
configuration metadata as possible between the various IoC containers out
there.</p>

<p>And while I like to think of SwiftSuspenders (especially in its future
2.0-form) as being a pretty decent IoC container implementation, you should
definitely check out <a href="http://github.com/sophistifunk/SmartyPants-IOC">SmartyPants</a>, <a href="http://swizframework.org/">Swiz</a>, <a href="https://github.com/sammyt/dawn">Dawn</a>,
<a href="http://www.spicefactory.org/parsley/index.php">Spicelib</a> and other IoC
containers if only out of interest. I&rsquo;d also like for you to tell me of you
don&rsquo;t like SwiftSuspenders or you think it&rsquo;s missing some Very Important
Feature, though. Anyway, to allow you to switch from or to SwiftSuspenders as
painlessly as possible, I&rsquo;ll implement as much of whatever everyone decides
upon as possible in 2.0 and future releases.</p>

<h3>That&rsquo;s quite a lot of work you just described. You really think you can handle all of it for 2.0?</h3>

<p>Yeah, I know: This sounds like (and is) a lot. I&rsquo;ll pack all of this up in the
form of a roadmap on the github wiki, prioritizing stuff and distributing it
across beta releases. Depending on when it makes sense to do a new major
release (which in turn depends on when we decide to release Robotlegs 2.0), I
<em>might</em> let one or two of the described features slip into 2.*.</p>

<p><strong>But</strong>, some of these features already exist in forks other people published on github and which I was very bad at keeping up with. It is my hope that I can integrate much of these other great people&rsquo;s hard work instead of doing much myself.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dictionaries in AS3: A tale of awesomeness and restrictions]]></title>
    <link href="http://tschneidereit.github.io/2011/01/14/dictionaries-in-as3-a-tale-of-awesomeness-and-restrictions/"/>
    <updated>2011-01-14T12:38:13+01:00</updated>
    <id>http://tschneidereit.github.io/2011/01/14/dictionaries-in-as3-a-tale-of-awesomeness-and-restrictions</id>
    <content type="html"><![CDATA[<p><strong>Update:</strong> <a href="http://twitter.com/stray_and_ruby">@stray_and_ruby</a> kindly made me aware of the fact that it isn&rsquo;t entirely obvious what this post is about. I&rsquo;m talking about a fairly obscure, but really handy usage of the <a href="http://www.adobe.com/livedocs/flash/9.0/ActionScriptLangRefV3/flash/utils/Dictionary.html">Dictionary class</a>: Implementing weak references to objects.<br/>
<a href="https://twitter.com/sunjammer">@sunjammer</a> recently <a href="http://www.doomsday.no/esn/2011/01/using-the-as3-dictionary-utility/">posted about the Dictionary class in AS3</a>. I agree with him: Dictionaries are awesome.</p>

<p>Unfortunately, they&rsquo;re only nearly as great as he describes them because of
one little snag: Weak Dictionaries are only &ldquo;weakly keyed&rdquo;, not &ldquo;weakly
valued&rdquo;, meaning that assigning an object as a value creates a strong
reference to that object &ndash; even if that very same object is also used as the
key for the entry.</p>

<p>That&rsquo;s especially unfortunate because it doesn&rsquo;t allow for efficiently
implementing weak references with low overhead:</p>

<p>Instead of using something like</p>

<p>```as3
package
{
  import flash.utils.Dictionary;
  public class WeakReference
  {</p>

<pre><code>private static const _referencesHolder : Dictionary = new Dictionary(true);
private static var _nextReferenceID : int = 0;
private const _referenceID : int = _nextReferenceID++;
public function WeakReference(target : *)
{
  _referencesHolder[_referenceID] = target;
}
public function get target() : *
{
  return _referencesHolder[_referenceID];
}
</code></pre>

<p>  }
}
```</p>

<p>you have to use something with much more overhead:</p>

<p>```as3
package
{
  import flash.utils.Dictionary;
  public class WeakReference
  {</p>

<pre><code>private const _referenceHolder : Dictionary = new Dictionary(true);
public function WeakReference(target : *)
{
  _referenceHolder[target] = true; //every basic type works as the value
}
public function get target() : *
{
  for (var value : * in _referenceHolder) return value;
  return null;
}
</code></pre>

<p>  }
}
```</p>

<p>On another note, I naturally had to <a href="http://www.google.com/search?q=awesomeness">google &ldquo;awesomeness&rdquo;</a> and what do you
think ensued? Correct: Awesomeness! Specifically, the result contained,
besides lots of links to Barney Stinson and HIMYM in general, <a href="http://www.awesomenessreminders.com/">this fantastic service</a>. I mean seriously: Who doesn&rsquo;t
like to be reminded of being awesome? And if you ask me, $45 a month is dirt
cheap for that happening reliably and on a daily basis. <em>(Just as the
providers of the service, I&rsquo;m only half-joking, btw. I&rsquo;m sure there are lots
of people out there whose life can be improved by such a service.)</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftSuspenders 1.5, or: A tale of robots and refactorings]]></title>
    <link href="http://tschneidereit.github.io/2010/05/15/swiftsuspenders-1-5-or-a-tale-of-robots-and-refactorings/"/>
    <updated>2010-05-15T17:41:01+02:00</updated>
    <id>http://tschneidereit.github.io/2010/05/15/swiftsuspenders-1-5-or-a-tale-of-robots-and-refactorings</id>
    <content type="html"><![CDATA[<p>Nearly half a year ago, I released
<a href="http://github.com/tschneidereit/SwiftSuspenders/">SwiftSuspenders</a> 1.0.</p>

<p>As hinted at in the <a href="http://www.tillschneidereit.de/2009/11/24/announcing-swiftsuspenders-1-0/">related blog post</a>,
this new release contains a solution to the &ldquo;Robot Legs Problem&rdquo;: and it goes by the name of <em>Child Injectors</em>.</p>

<p>So, why would robot legs pose a problem for a dependency injection container,
you ask. In short: They don&rsquo;t &ndash; their creation does. See, DI containers are
all about creating object graphs. That is: They allow you to create complex,
nested trees of objects in an automated fashion.</p>

<p>Want to build a car? You can either go about it manually from the outside in:
You create the car&rsquo;s shell, then you realize that your car probably needs an
engine. You put that in, at which point you realize that your engine will need
need cylinders, so you add some of those, and so on.</p>

<p>Or, you can use a DI container and do everything the other way around: You
first create a collection of all the parts your car will consist of, and then
you tell the DI container to instantiate the outermost part &ndash; the shell. The
container inspects the shell and sees that it needs some parts, like an
engine. It then looks through the set of parts you supplied, and adds those
that fit the dependencies of the shell. In doing so, each of the parts is
itself inspected and all its dependencies are fulfilled, recursively.</p>

<p>Now, imagine you want to build a robot. Robots aren&rsquo;t really special in any
way that&rsquo;s interesting for DI containers at all. It&rsquo;s just that their
construction is commonly used to explain a problem that you&rsquo;ll sooner or later
encounter if you use DI containers to create complex objects.</p>

<h4>What is the Robot Legs Problem?</h4>

<p>The robot legs problem describes the difficulties that one experiences when
trying to construct structures with two or more sub-trees that are very
similar, but not identical to one another.</p>

<p>See, that robot, it&rsquo;s supposed to look like a human being in many ways: It&rsquo;ll
have a head, a torso, two arms and two legs. But there&rsquo;s an important
difference to a human: The robot is much, much simpler. For example, parts of
this robot&rsquo;s legs are identical for both sides. Now ideally, if you&rsquo;ve got two
knee joints that are entirely identical to one another, you only want to
define them once. The problem is that for our robot, there are parts further
down the legs that differ for each side. say the knee joints are identical,
but the ankles are slightly different for each leg. How is the DI container
supposed to know that it has to supply different parts somewhere down the leg
if some intermediary parts are identical? It can&rsquo;t. Well, not without some
help, at least.</p>

<p><strong><em>That&rsquo;s the Robot Legs Problem.</em></strong></p>

<p>There are (at least) two solutions to this problem: Either you add some
differentiating attribute to the knee joints and all other parts that are
really the same, functionally; or you somehow add information to the DI
container&rsquo;s configuration that lets it figure out the differences from the
outside.</p>

<p>The first option isn&rsquo;t really attractive, but it&rsquo;s the easiest from a
conceptual point of view: Instead of having one class <code>Knee</code>, you create two classes, <code>LeftKnee</code> and <code>RightKnee</code>, both extending <code>Knee</code>. The only thing that differs for these classes
is that they define dependencies for <code>LeftAnkle</code>
and <code>RightAnkle</code> respectively (I&rsquo;m leaving out
any intermediary parts such as bones here for reasons of simplicity. For your
own, real-world, robot, you&rsquo;d probably want to have some of those). Apart from
adding a lot of boiler-plate code (imagine this with your real-world robot
that has about 53 parts in each leg that are functionally entirely identical
for both sides!), this creates serious problems in terms of separation of
concerns and encapsulation: If the knees truly are functionally identical,
it&rsquo;s none of their business to know anything about which leg they are added
to.</p>

<h4>What kind of solution does <a href="http://github.com/tschneidereit/SwiftSuspenders/">SwiftSuspenders</a> provide?</h4>

<p>Obviously, we want to use the second solution &ndash; and with
<a href="http://github.com/tschneidereit/SwiftSuspenders/">SwiftSuspenders</a> 1.5, we
finally can. The solution comes in the form of child injectors.</p>

<p>Child injectors are simple things: They try to satisfy all dependencies
themselves, but if they can&rsquo;t find a mapping for one, they turn to their
parent and ask if it has a corresponding mapping. Really, they&rsquo;re kinda dumb.</p>

<p>But here&rsquo;s the thing:
<a href="http://github.com/tschneidereit/SwiftSuspenders/">SwiftSuspenders</a> lets you
create trees of dependency mappings that use different child injectors to
satisfy recursive dependencies. In our example, you&rsquo;d create rules for the
<code>LeftHip</code> and the <code>RightHip</code>:</p>

<p><code>as3
var injector :
Injector = new Injector();
var leftHipRule : InjectionConfig = injector.mapClass(LeftHip, LeftHip);
var rightHipRule : InjectionConfig = injector.mapClass(RightHip, RightHip);
</code></p>

<p>Now in order to differentiate further down the leg, we create parallel structures for both legs in separate
injectors. But first, we need to create and set these injectors:</p>

<p><code>as3
//let your main injector create a child injector:
var leftLegInjector : Injector = injector.createChildInjector();
//you can also create a new injector and set its parent:
var rightLegInjector : Injector = new Injector();
rightLegInjector.setParentInjector(injector);
//Let SwiftSuspenders use the child injectors from the hip on down the leg:
leftHipRule.setInjector(leftLegInjector);
rightHipRule.setInjector(rightLegInjector);
</code></p>

<p>With this, our injectors are all set up as we need them &ndash; on to the remaining injection mappings.</p>

<p>Both <code>LeftHip</code> and <code>RightHip</code> have a dependency (and I&rsquo;m leaving out the thigh here)</p>

<p><code>as3
[Inject] public var knee : Knee;
</code></p>

<p>As this dependency is the same in both legs, we can safely add it to the main injector:</p>

<p><code>as3
injector.mapClass(Knee, Knee);
</code>
Upon not finding a rule for the <code>Knee</code> dependency,
the child injectors will turn to their parent and get the rule we just
defined. After using that to inject the <code>Knee</code>,
they will continue on down the tree of dependencies. The <code>Knee</code> has a dependency for an <code>Ankle</code>:</p>

<p><code>as3
[Inject] public
var ankle : Ankle;
</code></p>

<p>Not that the <code>Knee</code>
would care, but this field is actually supposed to contain a different value,
depending on which leg the <code>Knee</code> is added to!
Because of that, we have to add different mappings to the child injectors:</p>

<p><code>as3
leftLegInjector.mapClass(Ankle, LeftAnkle);
rightLegInjector.mapClass(Ankle, RightAnkle);
</code></p>

<p>And with that, we&rsquo;re done with the configuration! Assembling our robot is now a simple matter of letting
our injector instantiate the class <code>Robot</code>,
which of course defines dependencies for <code>LeftHip</code> and <code>RightHip</code>:</p>

<p><code>as3
var myRobot : Robot = injector.instantiate(Robot);
</code></p>

<h4>Great! And what about the refactorings?</h4>

<p>Right, the refactorings. Those have been applied to the
<a href="http://github.com/tschneidereit/SwiftSuspenders/">SwiftSuspenders</a> source
code. Lots of them, in fact. Their primary goal was to support child
injectors, but they also lead to a much cleaner separation of concerns.
Basically, there are now three basic building blocks in
<a href="http://github.com/tschneidereit/SwiftSuspenders/">SwiftSuspenders</a>, each with
their own very specific concern:</p>

<ul>
<li>The <code>Injector</code>, which acts as the facade to the entire system and keeps everything together</li>
<li>The <code>InjectionConfig</code>, which acts as the broker between injection points and injection results</li>
<li>Several kinds of <code>InjectionResult</code>s, which are held by <code>InjectionConfig</code>s and generate or keep the value that&rsquo;s injected into injection points</li>
</ul>


<p>In the future, <a href="http://www.youtube.com/watch?v=ATFxVB4JFpQ">robotic beings will rule the world</a>. Well, that, and the
aforementioned refactorings will allow for a better syntax for defining
injection mappings. Something along the lines of <code>injector.map(MyInterface, 'named').toClass(MyClass);</code>. But that&rsquo;s going to happen in the year 2000. Or version 2.0, I&rsquo;m not sure.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Improved reflection support in Flash Player 10.1?]]></title>
    <link href="http://tschneidereit.github.io/2009/11/22/improved-reflection-support-in-flash-player-10-1/"/>
    <updated>2009-11-22T01:23:14+01:00</updated>
    <id>http://tschneidereit.github.io/2009/11/22/improved-reflection-support-in-flash-player-10-1</id>
    <content type="html"><![CDATA[<h4>describeTypeJSON</h4>

<p>So it looks like Flash Player 10.1 <em>might</em> support a somewhat improved
reflections API containing support for:</p>

<ul>
<li>retrieving reflected information as JSON (or rather, as an AS3 object tree)</li>
<li>filtering the request to only retrieve certain types of information</li>
<li>Some more functions that are used internally to construct the result of describeType</li>
</ul>


<p>In other words, it containes improved access to the information available
through <code>describeType</code> and nothing more.</p>

<p>All of this functionality resides in the <code>avmplus</code> package in the
playerglobal.swc that can be <a href="http://labs.adobe.com/downloads/flashplayer10.html">downloaded from labs.adobe.com</a>.</p>

<p>This package contains a few methods and an assortment of constants:</p>

<p><img src="/images/posts/2009/11/reflection-in-fp-10_1.png" alt="reflection in fp 10.1" /></p>

<p>The most (or only, really) interesting of these is
<code>DescribeType.describeTypeJSON</code>. Using this method, it&rsquo;s possible to retrieve
reflection data as an object and to filter certain types of information using
the constants seen in the image above as bit flags. For example, to get only
information about the reflected classes constructor, you use the following
code:</p>

<p>```as3
DescribeType.describeTypeJSON(TargetClass,</p>

<pre><code>avmplus.INCLUDE_CONSTRUCTOR | 
avmplus.INCLUDE_TRAITS | avmplus.USE_ITRAITS);
</code></pre>

<p>```</p>

<p>Using the different flags, it&rsquo;s possible to request an object containing
exactly the information needed for a certain use-case. For example, in
<a href="http://github.com/tschneidereit/SwiftSuspenders">SwiftSuspenders</a>, I&rsquo;d use
the following code to get information about a types' methods, getters/setters,
variables and constructor, all with associated metadata:</p>

<p>```as3
DescribeType.describeTypeJSON(TargetClass,</p>

<pre><code>avmplus.INCLUDE_CONSTRUCTOR | 
avmplus.INCLUDE_METHODS | 
avmplus.INCLUDE_VARIABLES | 
avmplus.INCLUDE_ACCESSORS | 
avmplus.INCLUDE_METADATA | 
avmplus.HIDE_OBJECT | 
avmplus.INCLUDE_TRAITS | avmplus.USE_ITRAITS);
</code></pre>

<p>```</p>

<p>The last two flags have to be present to get any meaningful information at
all. I honestly have no idea why it&rsquo;d be necessary to explicitly state that,
yes, I want to include traits &ndash; you know, the mechanism with which the virtual
machine links everything to classes and without which a class is completely
uninteresting. And don&rsquo;t get me started on what <code>avmplus.USE_ITRAITS</code> stands
for.</p>

<p>All of this can also be used with the new <code>avmplus.describeType</code>, which is
essentially identical to <code>flash.utils.describeType</code> except that it adds an
additional parameter for the configuration flags:</p>

<p><code>as3
describeType(target : Object, flags : uint) : XML
</code></p>

<h4>Detours</h4>

<p>If you think that that&rsquo;s all you need to know about how to use this new API,
think again. All of these methods and the <code>DescribeType</code> class are implemented
as internal types of the <code>avmplus</code> package and thus not accessible from
outside this package. Fortunately, this can be worked around by creating a
public wrapper in the same package:</p>

<p><div><script src='https://gist.github.com/240357.js'></script>
<noscript><pre><code>package avmplus
{
	public class PublicDescribeType
	{
		public static function describeTypeJSON(target : Object, flags : uint) : Object
		{
			return DescribeType.describeTypeJSON(target, flags);
		}
		
		public function publicDescribeMetadata(xml : XML, metadata : Array) : void
		{
			describeMetadata(xml, metadata);
		}
		
		public function publicDescribeParams(xml : XML, parameters : Object) : void
		{
			describeParams(xml, parameters);
		}
		
		public function publicDescribeTraits(xml : XML, traits : Object) : void
		{
			describeTraits(xml, traits);
		}
		
		public function publicFinish(xml : XML, e : XML, i : Object) : void
		{
			finish(xml, e, i);
		}
	}
}</code></pre></noscript></div>
</p>

<h4>Is it all just a mistake?</h4>

<p>There are some things that are a bit fishy about this whole affair: Why is all
this functionality internal to the <code>avmplus</code> namespace? And what&rsquo;s with the
name &ldquo;avmplus&rdquo; in the first place? Seems like a weird choice to expose the
project name of the VM in such a way. Also, the API feels quite rough and
exposes functionality that&rsquo;s seemingly useless to AS3 developers.</p>

<p>Investigating some more, I discovered how this entire API came to be: It&rsquo;s the
new implementation of the old <code>describeType</code> functionality in the new version
of the ActionScript Virtual Machine, code named Tamarin Tracing. The <a href="http://hg.mozilla.org/tamarin-redux/rev/55b332e70e12">log message of the commit which added it</a> sheds some light on this. Since this initial commit,
<a href="http://hg.mozilla.org/tamarin-redux/log?rev=describetype">a few changes</a> have
been made, resulting in <a href="http://hg.mozilla.org/tamarin-redux/file/81b0b36ee7cb/core/DescribeType.as">the current version of the API</a> as exposed in 10.1
beta.</p>

<p>Now here&rsquo;s my guess about what&rsquo;s happened: When creating the Flash Player
beta, some configuration option was set the wrong way, causing the <code>avmplus</code>
package to be visible within playerglobal.swc, when it really should be an
invisible implementation detail. At the very least, the API in this state
probably isn&rsquo;t meant for public consumption and might well be removed in the
final 10.1 version.</p>

<h4>Now what?</h4>

<p>I&rsquo;d really like for this API to stay &ndash; be it in the current state or as a
polished version located in the <code>flash.utils</code> package or wherever.
Unfortunately, I&rsquo;m not sure what to do to that end; Adding a bug to the Flash
Player issue tracker to ask that something that&rsquo;s available in the beta should
stay that way in the final release seems odd.</p>
]]></content>
  </entry>
  
</feed>
