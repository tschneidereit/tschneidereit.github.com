<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Projects | Till Schneidereit]]></title>
  <link href="http://tillschneidereit.net//categories/projects/atom.xml" rel="self"/>
  <link href="http://tillschneidereit.net//"/>
  <updated>2014-04-05T15:56:51+02:00</updated>
  <id>http://tillschneidereit.net//</id>
  <author>
    <name><![CDATA[Till Schneidereit]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SwiftSuspenders 1.6: A Tale of Small Changes and Big Plans]]></title>
    <link href="http://tillschneidereit.net//2011/02/05/swiftsuspenders-1-6-a-tale-of-small-changes-and-big-plans/"/>
    <updated>2011-02-05T16:15:28+01:00</updated>
    <id>http://tillschneidereit.net//2011/02/05/swiftsuspenders-1-6-a-tale-of-small-changes-and-big-plans</id>
    <content type="html"><![CDATA[<p>I just released version 1.6 of my not-so-small-anymore IoC container
<a href="https://github.com/tschneidereit/SwiftSuspenders">SwiftSuspenders</a>. This
release marks the end of the line for 1.x-releases, all future development
work will go towards the all-new, shiny 2.0 release. Bug fixing will continue
as per usual, of course.</p>

<h3>Small Changes?</h3>

<p>Yes &ndash; in 1.6:</p>

<ul>
<li><p>An easy but nevertheless significant performance optimizations for child injectors: Through a slight refactoring of the InjectionPoint class, I was able to make it fully independent from the injector that creates them, enabling them to be shared among all injectors in the VM instance. This allows them to be cached once, removing the significant performance overhead associated in inspecting classes to find injection points for all but the first injector.</p></li>
<li><p>Some usability improvements such as better error, warning and info messages on trying to instantiate interfaces, re-mapping previously mapped types and construction of dummy instances to work around Flash Player bugs.</p></li>
</ul>


<h3>Right, but Big Plans?</h3>

<p>Indeed &ndash; for 2.0!</p>

<p>For the next major release, I plan to change things up quite a bit. The main
features on the roadmap are:</p>

<ul>
<li>a much nicer API</li>
<li>factory mappings</li>
<li>field mappings</li>
<li>live injections</li>
<li>optional injections</li>
<li>weak mappings in child injectors</li>
<li>full live-cycle management with [PreDestroy] annotations</li>
<li>a new format for external, runtime-loadable definition of both injection points and type mappings</li>
<li>full implementation of the <a href="https://github.com/darscan/AS3-DI-Metadata">metadata standardization</a> <a href="http://twitter.com/darscan">@darscan</a> started, for example:</li>
<li>optionally shortening <code>[Inject(name='name')]</code> to <code>[Inject('name')]</code></li>
</ul>


<h3>That sounds just swell, but I&rsquo;d really like some details, please!</h3>

<p>Of course you do!</p>

<h4>The shiny new API</h4>

<p>SwiftSuspenders' API mainly consists of methods that facilitate the mapping of
types (and, optionally, names) to responses. Internally, this already is a
two-step process: First, an object is created that contains the request
configuration (i.e., the type and the optional name) and second, this request
is assigned a response of a certain type: A value, class, singleton or rule
mapping.</p>

<p>While 2.0 will ship with a fa√ßade to make porting from 1.x easy, the real
interface will expose this process as the two steps it really is. Look forward
to seeing mapping commands that look (approximately) like this:</p>

<p><code>as3    
injector.map(YourClass); //current equivalent: injector.mapClass(YourClass, YourClass);
injector.map(YourClass, 'name'); //current equivalent: injector.mapClass(YourClass, YourClass, 'name');
injector.map(YourClass).to(YourClass); //equivalent to the first mapping (i.e.: optional)
injector.map(YourClass, 'name').to(YourClass); //equivalent to the second mapping (i.e.: optional)
injector.map(YourInterface).toType(YourClass); //current equivalent: injector.mapClass(YourInterface, YourClass);
injector.map(YourClass).asSingleton(); //current equivalent: injector.mapSingleton(YourClass);
injector.map(YourInterface).toType(YourClass).asSingleton(); //current equivalent: injector.mapSingletonOf(YourInterface, YourClass);
injector.map(YourInterface).toValue(value); //current equivalent: injector.mapValue(YourInterface, value);
injector.map(YourInterface).toRule(otherRule); //current equivalent: injector.mapRule(YourInterface, otherRule);
var request : InjectionRequest = injector.map(YourClass); //current equivalent: var request : InjectionConfig = injector.getMapping(YourClass);
</code></p>

<p>Basically, the API will be somewhat more DSL-ish, without going all the way
into that direction, though: I like to think of it as bundling up all
parameters related to one concept in one method call: First everything related
to <em>what</em> gets mapped, then, optionally, <em>to what</em> it gets mapped and finally,
<em>how</em> its being mapped.</p>

<p>Additionally, the small rest of the API will be subject to some tweaks, I
suppose.</p>

<h4>Factory mappings</h4>

<p>I haven&rsquo;t really gotten through the concept phase for these. The absolute
minimum is support for <code>injector.map().toFactory()</code> and
<code>injector.map().toFactoryMethod()</code>, but if I come up with some clever
mechanism for parameterizing specific injections, I would like to support that
as well.</p>

<h4>Field mappings</h4>

<p>In order to turn SwiftSuspenders into a light-weight one-way binding solution,
2.0 will support mapping of fields in objects with
<code>injector.map().toField(fieldName, inObject)</code>. If the mapped field is
bindable, SwiftSuspenders will listen to its change events and update the
affected live injections:</p>

<h4>Live injections</h4>

<p>Now those are something I&rsquo;m really looking forward to. By specifying the
<code>live</code>-parameter in your <code>Inject</code>-metadata (as in <code>[Inject(live)]</code>), you
basically create a one-way binding that updates the value as soon as the
associated mapping changes or, in the case of field mappings, the relevant
binding event is dispatched as described above.</p>

<h4>Optional injections</h4>

<p>These are exactly what you think they are. <code>[Inject(optional)]</code> will instruct
the injector not to throw an exception if it can&rsquo;t find a mapping for the
requested type.</p>

<h4>Weak mappings</h4>

<p>Imagine you have a module that you want to test &ndash; or perhaps even deploy &ndash;
standalone but <em>also</em> want to load into a bigger application. Now this module
might have some configuration that&rsquo;s different based on what context it gets
loaded into. If its loaded into another application, all or parts of the
configuration should be supplied by that application, but if its running
standalone, it has to deal with configuration all by itself. Enter weak
mappings: These instruct the injector to always ask its parent injector if it
has a mapping for the injection request. Only if that returns empty, the
weakly mapped value, in this case the module&rsquo;s configuration, is used.</p>

<h4>Tear-down with [PreDestroy]</h4>

<p>Just as <code>[Inject]</code> is used to build object graphs, <code>[PreDestroy]</code> facilitates
tearing them down. When instructed to destroy a certain instance that it
created itself or that was injected into with <code>injector.injectInto</code>,
SwiftSuspenders will first go through all injection points in the instance and
destroy those recursively (if they are only used by this instance, not if they
are singleton or value mappings, of course) and the invoke all methods marked
with <code>[PreDestroy]</code> metadata.</p>

<p>This will probably be used to replace the currently hard-coded <code>preRemove</code> and
<code>onRemove</code> methods in Robotlegs mediators.</p>

<h4>New runtime-loadable configuration format for injection points and mappings</h4>

<p>The current XML-based configuration format was solely meant to work around
restrictions in the Flash CS* AS3 compiler which doesn&rsquo;t support custom
metadata out of the box. This problem has since been <a href="http://www.patrickmowrer.com/2010/03/03/compiling-custom-as3-metadata-flash-professional">worked around</a>, rendering the format obsolete as it is right now. As
quite some people expressed interest in being able to mix hard-coded and
runtime-loaded configuration, I will try to come up with a good format for
that. For now, I don&rsquo;t have anything in that direction, so we&rsquo;ll see how that
goes. And if <em>you</em> want to define just such a format: Please do (and tell me
about it).</p>

<h4>Standardization FTW</h4>

<p>One thing I like about Robotlegs is how @darscan went to great lengths to
prevent as much lock-in as possible: Not only is the <a href="https://github.com/robotlegs/robotlegs-framework/blob/master/src/org/robotlegs/core/">framework&rsquo;s core</a>
just a set of interfaces that
makes it easy to roll your own for each part, the framework specifically tries
to make as many parts of your application independent and even ignorant of its
existence as possible. Toward that end, Shaun started a <a href="https://github.com/darscan/AS3-DI-Metadata">metadata standardization effort</a> with the
goal of getting as much agreement on the format of injection point-
configuration metadata as possible between the various IoC containers out
there.</p>

<p>And while I like to think of SwiftSuspenders (especially in its future
2.0-form) as being a pretty decent IoC container implementation, you should
definitely check out <a href="http://github.com/sophistifunk/SmartyPants-IOC">SmartyPants</a>, <a href="http://swizframework.org/">Swiz</a>, <a href="https://github.com/sammyt/dawn">Dawn</a>,
<a href="http://www.spicefactory.org/parsley/index.php">Spicelib</a> and other IoC
containers if only out of interest. I&rsquo;d also like for you to tell me of you
don&rsquo;t like SwiftSuspenders or you think it&rsquo;s missing some Very Important
Feature, though. Anyway, to allow you to switch from or to SwiftSuspenders as
painlessly as possible, I&rsquo;ll implement as much of whatever everyone decides
upon as possible in 2.0 and future releases.</p>

<h3>That&rsquo;s quite a lot of work you just described. You really think you can handle all of it for 2.0?</h3>

<p>Yeah, I know: This sounds like (and is) a lot. I&rsquo;ll pack all of this up in the
form of a roadmap on the github wiki, prioritizing stuff and distributing it
across beta releases. Depending on when it makes sense to do a new major
release (which in turn depends on when we decide to release Robotlegs 2.0), I
<em>might</em> let one or two of the described features slip into 2.*.</p>

<p><strong>But</strong>, some of these features already exist in forks other people published on github and which I was very bad at keeping up with. It is my hope that I can integrate much of these other great people&rsquo;s hard work instead of doing much myself.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftSuspenders 1.5, or: A tale of robots and refactorings]]></title>
    <link href="http://tillschneidereit.net//2010/05/15/swiftsuspenders-1-5-or-a-tale-of-robots-and-refactorings/"/>
    <updated>2010-05-15T17:41:01+02:00</updated>
    <id>http://tillschneidereit.net//2010/05/15/swiftsuspenders-1-5-or-a-tale-of-robots-and-refactorings</id>
    <content type="html"><![CDATA[<p>Nearly half a year ago, I released
<a href="http://github.com/tschneidereit/SwiftSuspenders/">SwiftSuspenders</a> 1.0.</p>

<p>As hinted at in the <a href="http://www.tillschneidereit.de/2009/11/24/announcing-swiftsuspenders-1-0/">related blog post</a>,
this new release contains a solution to the &ldquo;Robot Legs Problem&rdquo;: and it goes by the name of <em>Child Injectors</em>.</p>

<p>So, why would robot legs pose a problem for a dependency injection container,
you ask. In short: They don&rsquo;t &ndash; their creation does. See, DI containers are
all about creating object graphs. That is: They allow you to create complex,
nested trees of objects in an automated fashion.</p>

<p>Want to build a car? You can either go about it manually from the outside in:
You create the car&rsquo;s shell, then you realize that your car probably needs an
engine. You put that in, at which point you realize that your engine will need
need cylinders, so you add some of those, and so on.</p>

<p>Or, you can use a DI container and do everything the other way around: You
first create a collection of all the parts your car will consist of, and then
you tell the DI container to instantiate the outermost part &ndash; the shell. The
container inspects the shell and sees that it needs some parts, like an
engine. It then looks through the set of parts you supplied, and adds those
that fit the dependencies of the shell. In doing so, each of the parts is
itself inspected and all its dependencies are fulfilled, recursively.</p>

<p>Now, imagine you want to build a robot. Robots aren&rsquo;t really special in any
way that&rsquo;s interesting for DI containers at all. It&rsquo;s just that their
construction is commonly used to explain a problem that you&rsquo;ll sooner or later
encounter if you use DI containers to create complex objects.</p>

<h4>What is the Robot Legs Problem?</h4>

<p>The robot legs problem describes the difficulties that one experiences when
trying to construct structures with two or more sub-trees that are very
similar, but not identical to one another.</p>

<p>See, that robot, it&rsquo;s supposed to look like a human being in many ways: It&rsquo;ll
have a head, a torso, two arms and two legs. But there&rsquo;s an important
difference to a human: The robot is much, much simpler. For example, parts of
this robot&rsquo;s legs are identical for both sides. Now ideally, if you&rsquo;ve got two
knee joints that are entirely identical to one another, you only want to
define them once. The problem is that for our robot, there are parts further
down the legs that differ for each side. say the knee joints are identical,
but the ankles are slightly different for each leg. How is the DI container
supposed to know that it has to supply different parts somewhere down the leg
if some intermediary parts are identical? It can&rsquo;t. Well, not without some
help, at least.</p>

<p><strong><em>That&rsquo;s the Robot Legs Problem.</em></strong></p>

<p>There are (at least) two solutions to this problem: Either you add some
differentiating attribute to the knee joints and all other parts that are
really the same, functionally; or you somehow add information to the DI
container&rsquo;s configuration that lets it figure out the differences from the
outside.</p>

<p>The first option isn&rsquo;t really attractive, but it&rsquo;s the easiest from a
conceptual point of view: Instead of having one class <code>Knee</code>, you create two classes, <code>LeftKnee</code> and <code>RightKnee</code>, both extending <code>Knee</code>. The only thing that differs for these classes
is that they define dependencies for <code>LeftAnkle</code>
and <code>RightAnkle</code> respectively (I&rsquo;m leaving out
any intermediary parts such as bones here for reasons of simplicity. For your
own, real-world, robot, you&rsquo;d probably want to have some of those). Apart from
adding a lot of boiler-plate code (imagine this with your real-world robot
that has about 53 parts in each leg that are functionally entirely identical
for both sides!), this creates serious problems in terms of separation of
concerns and encapsulation: If the knees truly are functionally identical,
it&rsquo;s none of their business to know anything about which leg they are added
to.</p>

<h4>What kind of solution does <a href="http://github.com/tschneidereit/SwiftSuspenders/">SwiftSuspenders</a> provide?</h4>

<p>Obviously, we want to use the second solution &ndash; and with
<a href="http://github.com/tschneidereit/SwiftSuspenders/">SwiftSuspenders</a> 1.5, we
finally can. The solution comes in the form of child injectors.</p>

<p>Child injectors are simple things: They try to satisfy all dependencies
themselves, but if they can&rsquo;t find a mapping for one, they turn to their
parent and ask if it has a corresponding mapping. Really, they&rsquo;re kinda dumb.</p>

<p>But here&rsquo;s the thing:
<a href="http://github.com/tschneidereit/SwiftSuspenders/">SwiftSuspenders</a> lets you
create trees of dependency mappings that use different child injectors to
satisfy recursive dependencies. In our example, you&rsquo;d create rules for the
<code>LeftHip</code> and the <code>RightHip</code>:</p>

<p><code>as3
var injector :
Injector = new Injector();
var leftHipRule : InjectionConfig = injector.mapClass(LeftHip, LeftHip);
var rightHipRule : InjectionConfig = injector.mapClass(RightHip, RightHip);
</code></p>

<p>Now in order to differentiate further down the leg, we create parallel structures for both legs in separate
injectors. But first, we need to create and set these injectors:</p>

<p><code>as3
//let your main injector create a child injector:
var leftLegInjector : Injector = injector.createChildInjector();
//you can also create a new injector and set its parent:
var rightLegInjector : Injector = new Injector();
rightLegInjector.setParentInjector(injector);
//Let SwiftSuspenders use the child injectors from the hip on down the leg:
leftHipRule.setInjector(leftLegInjector);
rightHipRule.setInjector(rightLegInjector);
</code></p>

<p>With this, our injectors are all set up as we need them &ndash; on to the remaining injection mappings.</p>

<p>Both <code>LeftHip</code> and <code>RightHip</code> have a dependency (and I&rsquo;m leaving out the thigh here)</p>

<p><code>as3
[Inject] public var knee : Knee;
</code></p>

<p>As this dependency is the same in both legs, we can safely add it to the main injector:</p>

<p><code>as3
injector.mapClass(Knee, Knee);
</code>
Upon not finding a rule for the <code>Knee</code> dependency,
the child injectors will turn to their parent and get the rule we just
defined. After using that to inject the <code>Knee</code>,
they will continue on down the tree of dependencies. The <code>Knee</code> has a dependency for an <code>Ankle</code>:</p>

<p><code>as3
[Inject] public
var ankle : Ankle;
</code></p>

<p>Not that the <code>Knee</code>
would care, but this field is actually supposed to contain a different value,
depending on which leg the <code>Knee</code> is added to!
Because of that, we have to add different mappings to the child injectors:</p>

<p><code>as3
leftLegInjector.mapClass(Ankle, LeftAnkle);
rightLegInjector.mapClass(Ankle, RightAnkle);
</code></p>

<p>And with that, we&rsquo;re done with the configuration! Assembling our robot is now a simple matter of letting
our injector instantiate the class <code>Robot</code>,
which of course defines dependencies for <code>LeftHip</code> and <code>RightHip</code>:</p>

<p><code>as3
var myRobot : Robot = injector.instantiate(Robot);
</code></p>

<h4>Great! And what about the refactorings?</h4>

<p>Right, the refactorings. Those have been applied to the
<a href="http://github.com/tschneidereit/SwiftSuspenders/">SwiftSuspenders</a> source
code. Lots of them, in fact. Their primary goal was to support child
injectors, but they also lead to a much cleaner separation of concerns.
Basically, there are now three basic building blocks in
<a href="http://github.com/tschneidereit/SwiftSuspenders/">SwiftSuspenders</a>, each with
their own very specific concern:</p>

<ul>
<li>The <code>Injector</code>, which acts as the facade to the entire system and keeps everything together</li>
<li>The <code>InjectionConfig</code>, which acts as the broker between injection points and injection results</li>
<li>Several kinds of <code>InjectionResult</code>s, which are held by <code>InjectionConfig</code>s and generate or keep the value that&rsquo;s injected into injection points</li>
</ul>


<p>In the future, <a href="http://www.youtube.com/watch?v=ATFxVB4JFpQ">robotic beings will rule the world</a>. Well, that, and the
aforementioned refactorings will allow for a better syntax for defining
injection mappings. Something along the lines of <code>injector.map(MyInterface, 'named').toClass(MyClass);</code>. But that&rsquo;s going to happen in the year 2000. Or version 2.0, I&rsquo;m not sure.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing SwiftSuspenders]]></title>
    <link href="http://tillschneidereit.net//2009/09/21/introducing-swiftsuspenders/"/>
    <updated>2009-09-21T16:20:43+02:00</updated>
    <id>http://tillschneidereit.net//2009/09/21/introducing-swiftsuspenders</id>
    <content type="html"><![CDATA[<h4>Working with RobotLegs</h4>

<p>Recently, I started working with the awesome MVCS framework
<a href="http://github.com/darscan/robotlegs/">RobotLegs</a> by <a href="http://shaun.boyblack.co.za/blog/">Shaun Smith</a>.</p>

<p>As I&rsquo;m not a big fan of the configuration overhead that the Spring framework
for <a href="http://en.wikipedia.org/wiki/Dependency_Injection">Dependency Injection</a>
brings with it, I immediately fell in love with the metadata based
<a href="http://code.google.com/p/smartypants-ioc/">SmartyPants IOC framework</a>. While
I really like the approach and everything worked great, I quickly realized
that SmartyPants has two problems: It&rsquo;s somewhat slow and, due to some
dependencies on the Flex framework, rather big.</p>

<h4>SwiftSuspenders: A fast, lightweight DI solution</h4>

<p>That&rsquo;s why I started implementing an ultra lightweight DI framework (which
hardly even deserves being called a framework) which then became
<a href="http://github.com/tschneidereit/SwiftSuspenders">SwiftSuspenders</a>.</p>

<p>SwiftSuspenders implements exactly the functionality needed by RobotLegs,
nothing more, but, crucially, nothing less &ndash; and it does so as fast and as
lean as possible. By focusing on these needs, I was able to implement a
solution that&rsquo;s about an order of magnitude faster and weighs only 10% of
SmartyPants file size-wise. And yes: Both of these values are SWAGs and
shouldn&rsquo;t be relied on for, well, anything.</p>

<p>Right after I published SwiftSuspenders on GitHub &ndash; as you should do with
everything you build that might be of help to your esteemed colleagues &ndash;
awesome stuff happened: Shaun Smith immediately forked to project, started
fixing bugs and embarrasing mistakes in the documentation and switched most of
the <a href="http://github.com/darscan/robotlegsdemos">examples for RobotLegs</a> to
using SwiftSuspenders and hinted at creating unit tests &ndash; which I shamefully
neglected. Yesterday, he followed up on that and pushed a range of unit tests
to a new <a href="http://github.com/darscan/SwiftSuspendersTests">GitHub project</a>!</p>

<h4>What now?</h4>

<p>Apart from you reading the <a href="http://github.com/tschneidereit/SwiftSuspenders/blob/master/README.textile">introductory documentation</a>, starting to use
SwiftSuspenders and forking it on GitHub? I&rsquo;m not sure.</p>

<p>I think that maybe, SwiftSuspenders is pretty much done as it is. SmartyPants
still has <a href="http://code.google.com/p/smartypants-ioc/wiki/Rules">some features</a>
that SwiftSuspenders doesn&rsquo;t, but for now, I don&rsquo;t think that those are really
essential. Then again, I might implement Provider Binding and Rule Binding
sometimes later &ndash; whereas I can almost guarantee that I won&rsquo;t implement live
bindings.</p>
]]></content>
  </entry>
  
</feed>
